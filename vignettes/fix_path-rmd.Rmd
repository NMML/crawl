---
title: "Fixing Animal Movement Paths Around Barriers"
subtitle: "a vignette in support of the `crawl` R package"
author:
- name: Josh M. London
  affiliation: 1
- name: Devin S. Johnson
  affiliation: 2
address:
- code: 1
  address: Alaska Fisheries Science Center, NOAA Fisheries, Seattle, Washington, USA 
  email: josh.london@noaa.gov
  orcid: orcid.org/0000-0002-3647-5046
- code: 2
  address: Alaska Fisheries Science Center, NOAA Fisheries, Seattle, Washington, USA 
  email: devin.johnson@noaa.gov 
date: "`r Sys.Date()`"
abstract: >
  The `crawl` package provides an analytical framework for developing models of animal movement from telemetry data. The focus is on telemetry data with location error and obtained at irregular intervals. Studies of marine mammals that rely on the Argos satellite system for location estimates fall within this category. Many marine mammal species are coastal (and, in the case of pinnipeds, come ashore at times). This, along with the error inherent in Argos and GPS locations inevitably results in the presence of locations on shore that are not plausible. The `crwMLE()` model fitting function within `crawl` does not incorporate the presence of land as a barrier to movement. To account for any non-plausible locations, we provide the `fix_path()` function. This is a post-hoc adjustment of those track segments that cross the specified barrier. The adjustment is based on key parameters from the model fit as well as a series of waypoints that are laid down along the shortest barrier path (e.g. coastline).
output: 
  uswebr::html_uswds:
    number_sections: FALSE
vignette: >
  %\VignetteIndexEntry{Fixing Animal Movement paths Around Barriers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  error = FALSE,
  message = FALSE
)
# library(showtext)
# ## Loading Google fonts (http://www.google.com/fonts)
# font_add_google("Source Sans Pro")
# ## Automatically use showtext to render text
# showtext_auto()

devtools::load_all("..")
```

# Example with Alaska Harbor Seal Track

The `harborseal_sf` data included within the `crawl` package is used here as
an example. First, we will plot the observed locations. `harborseal_sf` is
already an `sf` object so we can use the built-in spatial capabilities of
the `ggplot2` package. The `ggspatial` package provides additional spatial
mapping capabilities e.g., automatically setting a sensible plot area. We can
also include a background layer based on freely available map tiles. Here, we
will use the ESRI World Ocean Basemap.

```{r harborseal-sf-map, fig.cap='A map of observed Argos locations from a telemetry deployment on a single harbor seal in Alaska.'}
library(tidyverse)
library(sf)
library(ggspatial)

data(harborSeal_sf)
harborSeal_sf$Argos_loc_class = factor(harborSeal_sf$Argos_loc_class, levels=c("3","2","1","0","A","B"))
harborSeal_sf <- harborSeal_sf %>% 
  sf::st_transform(3338)

esri_ocean <- paste0('https://services.arcgisonline.com/arcgis/rest/services/',
                     'Ocean/World_Ocean_Base/MapServer/tile/${z}/${y}/${x}.jpeg')

ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 1,progress = "none") +
  layer_spatial(harborSeal_sf, size = 0.5) +
  scale_x_continuous(expand = expand_scale(mult = c(.5, .5))) +
  ggtitle("Observed Argos Locations", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Fitting a Movement Model with `crwMLE`

The next step is to fit a movement model from the observed locations using the
`crwMLE()` function. We will use the published errors for Argos location
classes _3_, _2_, and _1_. Error classes _0_, _A_, and _B_ will be estimated.
We also use the `DryTime` data to inform the `activity` parameter.

```{r model-fit, results = 'hide'}
fixPar = c(log(250), log(500), log(1500), rep(NA,5), 0)
displayPar( mov.model = ~1, 
            err.model = list(x = ~Argos_loc_class-1),
            data = harborSeal_sf, 
            activity = ~I(1-DryTime),fixPar = fixPar)
constr = list(
  lower = c(rep(log(1500),3), rep(-Inf,2)),
  upper = rep(Inf,5)
)

set.seed(123)
fit1 <- crwMLE(
  mov.model = ~1, 
  err.model = list(x = ~Argos_loc_class-1), 
  activity = ~I(1-DryTime),
  data = harborSeal_sf, 
  Time.name = "Time", 
  fixPar = fixPar, 
  theta = c(rep(log(5000),3),log(3*3600), 0),
  constr = constr,
  control = list(maxit = 2000, trace = 1, REPORT = 1)
)
```

Now that we have our model fit, we can predict the most likely path for this
harbor seal. We will make predictions at hourly time intervals and, then, 
we will use the `crw_as_sf()` function to convert the predicted path to an
`sf` _LINESTRING_ and plot.

```{r, path-predict, fig.cap='A map of the predicted path from a telemetry deployment on a single harbor seal in Alaska. Predictions estimated at hourly time intervals'}
pred1 = crwPredict(fit1, predTime = "1 hour")
pred1_sf <- pred1 %>% crawl::crw_as_sf("LINESTRING")

ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 1,progress = "none") +
  layer_spatial(pred1_sf, lwd = 0.5) +
  scale_x_continuous(expand = expand_scale(mult = c(.5, .5))) +
  ggtitle("Predicted Path", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Isolate a Small Portion of Track and Re-Fit

If we look at the predicted path, we can see a number of segments where the
track crosses land. In a normal workflow, we would pass this `crwPredict` object
on to the `fix_path()` function. For ease of demonstration, we will isolate a
small portion of the track where there is a significant portion that crosses
land.

```{r refit-subset, results='hide'}
harborSeal_sf <- harborSeal_sf %>% 
  dplyr::slice(550:1000)
fixPar = c(log(250), log(500), log(1500), rep(NA,5), 0)
displayPar( mov.model = ~1, err.model = list(x = ~Argos_loc_class-1),
            data = harborSeal_sf, 
            activity = ~I(1-DryTime),fixPar = fixPar)
constr = list(
  lower = c(rep(log(1500),3), rep(-Inf,2)),
  upper = rep(Inf,5)
)

set.seed(123)
fit1 <- crwMLE(
  mov.model = ~1, 
  err.model = list(x = ~Argos_loc_class-1), 
  activity = ~I(1-DryTime),
  data = harborSeal_sf, 
  Time.name = "Time", 
  fixPar = fixPar, 
  theta = c(rep(log(5000),3),log(3*3600), 0),
  constr = constr,
  control = list(maxit = 2000, trace = 1, REPORT = 1)
)

pred1 = crwPredict(fit1, predTime = "1 hour")
pred1_sf <- pred1 %>% crawl::crw_as_sf("POINT")
pred1_line <- pred1 %>% crawl::crw_as_sf("LINESTRING")
```

Instead of using the ESRI World Ocean Basemap, we will now use data from the
GSHHG dataset available within the `ptolemy` package. This will
allow us to create a polygon layer that will serve as our land mask.

```{r path-predict-ne, results = 'hide', fig.cap='A map of the predicted path from an isolated portion of a telemetry deployment on a single harbor seal in Alaska. Predictions estimated at hourly time intervals. Land mask from GSHHG/ptolemy'}
library(ptolemy)
ak_sf <- ptolemy::alaska()

ggplot() + 
  ggspatial::annotation_spatial(data = ak_sf) +
  ggspatial::layer_spatial(pred1_line, lwd = 0.75, color = '#159957') +
  scale_x_continuous(expand = expand_scale(mult = c(.6, .6))) +
  ggtitle("Predicted Path for Isolated Portion", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Identifying Path Segments That Cross Land

The coordinate data and uncertainty are stored within the `crw_object` as
_mu.x_, _nu.x_, _mu.y_, _nu.y_. The `crw_alpha()` function provides
convenient access to this information. We refer to this vector of parameters
as _alpha_ and we will pass that along with `pred1_sf` for *crw_sf* and `ak_sf`
as *vector_mask* to `get_mask_segments()`

### `crw_alpha`

Extract alpha values from the provided `crwPredict` or `crwIS` object. 

```{r crw-alpha, results = 'hide'}
crw_alpha <- function(crw_object) {
  ts <- attr(crw_object,"time.scale")
  if (inherits(crw_object,"crwIS")) {
    alpha <- crw_object$alpha.sim
    times <- crw_object$Time
  }
  
  if (inherits(crw_object,"crwPredict")) {
    alpha <- data.matrix(crw_object[,c("mu.x","nu.x","mu.y","nu.y")])
    times <- crw_object[,attr(crw_object,"Time.name")]
  }
  out <- list(alpha = alpha,
              times = as.numeric(times)/ts)
  class(out) <- "crwAlpha"
  return(out)
}
```


### `get_mask_segments`

This function is used to identify sections of a path that pass through a
restricted area (e.g. for marine mammals or fish, a land mask). This function will
identify path segments from the unrestrained path that overlap the *vector_mask*.
If the path/points end within the land area, those records will be removed. The
user can then use this information to adjust the path as desired.

```{r get-mask-segments, results = 'hide'}
get_mask_segments = function(crw_sf, vector_mask, alpha) {
  
  # intersect crw_sf with vector mask
  on_mask <- sf::st_intersects(crw_sf, vector_mask) %>% 
    purrr::map_lgl(~ length(.x) > 0)
  if (any(is.na(on_mask))) {
    stop("points in crw_sf fall outside the extent of vector_mask")
  }
  # return NULL if no points within the vector mask
  if (sum(on_mask,na.rm = TRUE) == 0) {return(NULL)}
  
  head_start <- 1
  tail_end <- length(on_mask)
  
  if (min(which(on_mask == TRUE)) == 1) {
    warning(paste0("Path starts within vector mask, first ",
                   min(which(on_mask == 0)) - 1,
                   " observations removed"))
    head_start = min(which(on_mask == FALSE))
  }
  if (max(which(on_mask == 0)) < length(on_mask)) {
    warning(paste("Path ends within vector mask, last ", 
                  length(on_mask) - max(which(on_mask == 0)),
                  " observations removed"))
    tail_end <- max(which(on_mask == 0))
  }
  crw_sf <- crw_sf[head_start:tail_end,]
  on_mask <- on_mask[head_start:tail_end]
  
  in.segment <- (on_mask == TRUE)
  
  start_idx <- which(c(FALSE, in.segment) == TRUE &
                       dplyr::lag(c(FALSE, in.segment) == FALSE)) - 2
  end_idx <- which(c(in.segment, FALSE) == TRUE & 
                     dplyr::lead(c(in.segment, FALSE) == FALSE)) + 1
  on_mask_segments <- data.frame(start_idx, end_idx) %>% 
    rowwise() %>% 
    dplyr::mutate(start_alpha = list(alpha$alpha[start_idx, ]),
                  end_alpha = list(alpha$alpha[end_idx,]),
                  times = list(alpha$times[start_idx:end_idx]))
  on_mask_segments <- list(
    on_mask_segments = on_mask_segments,
    fixed_range = c(head_start,tail_end)
  )
  
  return(on_mask_segments)
}
```



```{r identify-segments, results = 'hide'}
alpha <- crw_alpha(pred1)

segments <- get_mask_segments(crw_sf = pred1_sf,
                              vector_mask = ak_sf,
                              alpha = alpha)$on_mask_segments

pred1_sf$L1 <- 0

for (i in 1:nrow(segments)) {
  start_idx <- segments$start_idx[i]
  end_idx <- segments$end_idx[i]
  pred1_sf$L1[start_idx:end_idx] <- i
}

pred1_fix <- pred1_sf %>% dplyr::group_by(L1) %>%
  dplyr::summarise(do_union=FALSE) %>%
  sf::st_cast("LINESTRING") %>% 
  dplyr::filter(L1 > 0)

ggplot() + 
  ggspatial::annotation_spatial(data = ak_sf) +
  ggspatial::layer_spatial(pred1_line, lwd = 0.75, color = '#159957') +
  ggspatial::layer_spatial(pred1_fix, lwd = 1.5, color = 'dark red') +
  scale_x_continuous(expand = expand_scale(mult = c(.5, .5))) +
  ggtitle("Predicted Path Highlighting On-Land Segments", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Identifying the Shortest Coastline Path

For this example, we will focus on the largest over-land segment. To identify
the specific portion of the path, we can examine _segments_

```{r}
segments
```

The second entry in _segments_ represents this protion of the path. The
goal is to have `fix_path()` route a new path along the coastline to the west.
We can use several geo-spatial functions provided by the `sf` and `lwgeom`
packages to extract this stretch of coastline.

The general idea is to create a straight line from the start and end points of
each segment (both of which will be in-water). We use this line to split the
*vector_mask* polygon using the `lwgeom::st_split()` function. In the case
where the straight line only crosses a single polygon, we can simply select the
smallest area polygon as it will contain the shortest coastline distance between
our two points. At this point, we employ a series of additional functions and
conversions to end up with a line feature.

```{r}
vector_mask <- ak_sf
crw_sf <- pred1_sf
barrier_buffer <- 50
crwIS = FALSE

segments$fixed_seg <- vector(mode = "list", length = nrow(segments))

i <- 3

start_idx <- segments[i, "start_idx"][[1]]
end_idx <- segments[i, "end_idx"][[1]]


start_pt = sf::st_point(segments[i,]$start_alpha[[1]][c("mu.x", "mu.y")])
end_pt = sf::st_point(segments[i,]$end_alpha[[1]][c("mu.x", "mu.y")])
fix_line <- sf::st_linestring(rbind(start_pt, end_pt)) %>%
  sf::st_sfc() %>% sf::st_set_crs(sf::st_crs(crw_sf))

n_polys <- vector_mask %>%
  sf::st_cast("POLYGON") %>%
  st_intersects(fix_line, sparse = FALSE) %>%
  sum()

if (n_polys == 0) {
  coast_line <- fix_line
}

if (n_polys == 1) {
      coast_line <- vector_mask %>%
        sf::st_cast("POLYGON") %>%
        dplyr::filter(lengths(st_intersects(., fix_line)) > 0) %>%
        lwgeom::st_split(fix_line) %>%
        sf::st_collection_extract("POLYGON") %>%
        dplyr::slice(which.min(st_area(.))) %>% 
        sf::st_buffer(barrier_buffer) %>%
        st_union(fix_line) %>%  
        sf::st_convex_hull() %>% 
        sf::st_cast("LINESTRING")  %>% 
        lwgeom::st_split(st_buffer(fix_line, dist = 1e-10)) %>%
        sf::st_collection_extract("LINESTRING") %>%
        dplyr::slice(which.max(st_length(.)))
    }

if (n_polys > 1) {
  stop(paste("an on-land segment crosses more than one polygon.",
             "this scenario is currently not supported. the best",
             "solution is to increase the frequency of prediction",
             "times or reduce complexity of the vector mask."))
}

```


```{r}
ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 1, progress = "none") +
  layer_spatial(fix_line %>% st_sf(), lwd = 0.5, color = 'dark red',
                linetype = 11) +
  layer_spatial(coast_line, lwd = 1.5, color = 'dark blue') +
  scale_x_continuous(expand = expand_scale(mult = c(.5, .5))) +
  ggtitle("Shortest Coastline Between Points")
```

The `fix_path()` approach relies on a series of _waypoints_ that are placed
evenly along the shortest coastline path. These _waypoints_ serve to anchor/guide
the model parameters as a new path is developed. We have chosen to set the
number of _waypoints_ at 4x the number of locations within the segment.

```{r}
# length of the segment is determined from the times column
data_times <- list(times = segments[i,]$times[[1]],
                   type = "data") %>%
  tibble::as_tibble()

wypt_times <- list(times = c(seq(
  data_times$times[1],
  data_times$times[nrow(data_times)],
  by = 0.25
))) %>%
  tibble::as_tibble()

l <- nrow(wypt_times)

data_times <- data_times %>%
  dplyr::slice(2:(n() - 1))

start_pt <- start_pt %>% 
      sf::st_sfc() %>%
      sf::st_set_crs(sf::st_crs(crw_sf))
    
    end_pt <- end_pt %>% 
      sf::st_sfc() %>% 
      sf::st_set_crs(sf::st_crs(crw_sf))
    
coast_points <- coast_line %>% 
      sf::st_sample(l-2,type="regular",offset=runif(1)) %>% 
      sf::st_cast("POINT") %>% 
      sf::st_coordinates() %>%
      rbind(sf::st_coordinates(start_pt),.,st_coordinates(end_pt)) %>% 
      tibble::as_tibble() %>% 
      dplyr::rename(mu.x = X, mu.y = Y) %>% 
      dplyr::bind_cols(wypt_times) %>% 
      dplyr::mutate(type = "wypt") %>% 
      dplyr::mutate(type = case_when(
        row_number() == 1L ~ "start",
        row_number() == l ~ "end",
        TRUE ~ type
      )) %>% 
      dplyr::mutate(nu.x = case_when(
        type == "start" ~ crw_sf$nu.x[start_idx],
        type == "end" ~ crw_sf$nu.x[end_idx],
        TRUE ~ NA_real_
      ),
      nu.y = case_when(
        type == "start" ~ crw_sf$nu.y[start_idx],
        type == "end" ~ crw_sf$nu.y[end_idx],
        TRUE ~ NA_real_
      )) %>% 
      dplyr::full_join(data_times) %>% 
      dplyr::arrange(times) %>% 
      dplyr::select(type,mu.x,nu.x,mu.y,nu.y,times)
```

```{r eval=FALSE}
ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 1, progress = "none") +
  layer_spatial(fix_line %>% st_sf(), lwd = 0.5, color = 'dark red',
                linetype = 11) +
  layer_spatial(coast_line, lwd = 0.5, color = 'dark blue') +
  layer_spatial(coast_points %>% st_sf(), size = 1, color = '#159957') +
  scale_x_continuous(expand = expand_scale(mult = c(.5, .5))) +
  ggtitle("Distribution of Waypoints")
```

## Considerations Before Proceeding

At this point, we have all of the basis information and parameters needed
to proceed with estimation of a new path segment that is routed around the
land feature. But, it is a good time to review the input data and some of the
assumptions.

If you examine the maps above, you'll notice the coastline from the Natural
Earth data does not quite match the ESRI World Ocean Basemap. The importance
of this discrepancy will depend on your data and the questions of interest.
Since the waypoints along the coastline only serve as anchors, some discrepancy
should be tolerable for most applications.

In this example, the function can only handle when the straight line between
in-water locations crosses one polygon feature. Future development will allow
up to three polygon crossings. But, more than that, and you will need to either
increase the number of predicted locations OR simplify the supplied vector mask.

## Fix Predicted Path

```{r}
par <- tail(fit1$estPar, 2)

if (!crwIS) {
      segments[[i,"fixed_seg"]] <- path_prediction_fix(coast_points, 
                                                     sigma = exp(par[1]), 
                                                     beta = exp(par[2]))
    }
    if (crwIS) {
      segments[[i,"fixed_seg"]] <- path_simulation_fix(coast_points, 
                                                     sigma = exp(par[1]), 
                                                     beta = exp(par[2])) 
    }
```
