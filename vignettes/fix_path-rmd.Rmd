---
title: "Fixing Animal Movement Paths Around Barriers"
author: "Josh M. London"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: cayman
    fig_width: 8
    fig_height: 8
    fig_retina: 2
    fig_align: center
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  error = FALSE,
  message = FALSE
)
devtools::load_all("..")
```

# Executive Summary

The `crawl` package provides an analytical framework for developing models of
animal movement from telemetry data. The focus is on telemetry data with
location error and obtained at irregular intervals. Studies of marine mammals
that rely on the Argos satellite system for location estimates fall within this
category. Many marine mammal species are coastal (and, in the case of pinnipeds,
come ashore at times). This, along with the error inherent in Argos and GPS
locations inevitably results in the presence of locations on shore that are not
plausible. The `crwMLE()` model fitting function within `crawl` does not
incorporate the presence of land as a barrier to movement. To account for any
non-plausible locations, we provide the `fix_path()` function. This is a post-hoc
adjustment of those track segments that cross the specified barrier. The
adjustment is based on key parameters from the model fit as well as a series of
waypoints that are laid down along the shortest barrier path (e.g. coastline).

# Example with Alaska Harbor Seal Track

The `harborseal_sf` data included within the `crawl` package is used here as
an example. First, we will plot the observed locations. `harborseal_sf` is
already an `sf` object so we can use the built-in spatial capabilities of
the `ggplot2` package. The `ggspatial` package provides additional spatial
mapping capabilities e.g., automatically setting a sensible plot area. We can
also include a background layer based on freely available map tiles. Here, we
will use the ESRI World Ocean Basemap.

```{r harborseal-sf-map, fig.cap='A map of observed Argos locations from a telemetry deployment on a single harbor seal in Alaska.'}
library(tidyverse)
library(sf)
library(ggspatial)

data(harborSeal_sf)
harborSeal_sf$Argos_loc_class = factor(harborSeal_sf$Argos_loc_class, levels=c("3","2","1","0","A","B"))
harborSeal_sf <- harborSeal_sf %>% 
  sf::st_transform(3338)

esri_ocean <- paste0('https://services.arcgisonline.com/arcgis/rest/services/',
                     'Ocean/World_Ocean_Base/MapServer/tile/${z}/${y}/${x}.jpeg')

ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 2,progress = "none") +
  layer_spatial(harborSeal_sf, size = 0.5) +
  ggtitle("Observed Argos Locations", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Fitting a Movement Model with `crwMLE`

The next step is to fit a movement model from the observed locations using the
`crwMLE()` function. We will use the published errors for Argos location
classes _3_, _2_, and _1_. Error classes _0_, _A_, and _B_ will be estimated.
We also use the `DryTime` data to inform the `activity` parameter.

```{r model-fit, results = 'hide'}
fixPar = c(log(250), log(500), log(1500), rep(NA,5), 0)
displayPar( mov.model=~1, err.model=list(x=~Argos_loc_class-1),data=harborSeal_sf, 
            activity=~I(1-DryTime),fixPar=fixPar)
constr=list(
  lower=c(rep(log(1500),3), rep(-Inf,2)),
  upper=rep(Inf,5)
)

set.seed(123)
fit1 <- crwMLE(
  mov.model=~1, 
  err.model=list(x=~Argos_loc_class-1), 
  activity=~I(1-DryTime),
  data=harborSeal_sf, 
  Time.name="Time", 
  fixPar=fixPar, 
  theta=c(rep(log(5000),3),log(3*3600), 0),
  constr=constr,
  control=list(maxit=2000, trace=1, REPORT=1)
)
```

Now that we have our model fit, we can predict the most likely path for this
harbor seal. We will make predictions at hourly time intervals and, then, 
we will use the `crw_as_sf()` function to convert the predicted path to an
`sf` _LINESTRING_ and plot.

```{r, path-predict, fig.cap='A map of the predicted path from a telemetry deployment on a single harbor seal in Alaska. Predictions estimated at hourly time intervals'}
pred1 = crwPredict(fit1, predTime="1 hour")
pred1_sf <- pred1 %>% crawl::crw_as_sf("LINESTRING")

ggplot() + 
  annotation_map_tile(type = esri_ocean,zoomin = 2,progress = "none") +
  layer_spatial(pred1_sf, lwd = 0.5) +
  ggtitle("Predicted Path", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Isolate a Small Portion of Track and Re-Fit

If we look at the predicted path, we can see a number of segments where the
track crosses land. In a normal workflow, we would pass this `crwPredict` object
on to the `fix_path()` function. For ease of demonstration, we will isolate a
small portion of the track where there is a significant portion that crosses
land.

```{r refit-subset, results='hide'}
harborSeal_sf <- harborSeal_sf %>% 
  dplyr::slice(550:1000)
fixPar = c(log(250), log(500), log(1500), rep(NA,5), 0)
displayPar( mov.model=~1, err.model=list(x=~Argos_loc_class-1),
            data=harborSeal_sf, 
            activity=~I(1-DryTime),fixPar=fixPar)
constr=list(
  lower=c(rep(log(1500),3), rep(-Inf,2)),
  upper=rep(Inf,5)
)

set.seed(123)
fit1 <- crwMLE(
  mov.model=~1, 
  err.model=list(x=~Argos_loc_class-1), 
  activity=~I(1-DryTime),
  data=harborSeal_sf, 
  Time.name="Time", 
  fixPar=fixPar, 
  theta=c(rep(log(5000),3),log(3*3600), 0),
  constr=constr,
  control=list(maxit=2000, trace=1, REPORT=1)
)

pred1 = crwPredict(fit1, predTime="1 hour")
pred1_sf <- pred1 %>% crawl::crw_as_sf("POINT")
pred1_line <- pred1 %>% crawl::crw_as_sf("LINESTRING")
```

Instead of using the ESRI World Ocean Basemap, we will now use data from the
Natural Earth II dataset available within the `rnaturalearth` package. This will
allow us to create a polygon layer that will serve as our land mask.

```{r path-predict-ne, results = 'hide', fig.cap='A map of the predicted path from an isolated portion of a telemetry deployment on a single harbor seal in Alaska. Predictions estimated at hourly time intervals. Land mask from Natural Earth'}
library(rnaturalearth)
ak_sf <- rnaturalearth::ne_download(category = 'physical',type = 'land', 
                   scale = 10, returnclass = 'sf',
                   destdir = '~/_projects/r/ne_local') %>% 
  sf::st_transform(3338)

ggplot() + 
  ggspatial::annotation_spatial(data = ak_sf) +
  ggspatial::layer_spatial(pred1_line, lwd = 0.75, color = '#159957') +
  ggtitle("Predicted Path for Isolated Portion", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

## Identifying Path Segments That Cross Land

The coordinate data and uncertainty are stored within the `crw_object` as
_mu.x_, _nu.x_, _mu.y_, _nu.y_. The `crw_alpha()` function provides
convenient access to this information. We refer to this vector of parameters
as _alpha_ and we will pass that along with `pred1_sf` for *crw_sf* and `ak_sf`
as *vector_mask* to `get_mask_segments()`

### `crw_alpha`

Extract alpha values from the provided `crwPredict` or `crwIS` object. 

```{r crw-alpha, results = 'hide'}
crw_alpha <- function(crw_object) {
  ts <- attr(crw_object,"time.scale")
  if (inherits(crw_object,"crwIS")) {
    alpha <- crw_object$alpha.sim
    times <- crw_object$Time
  }
  
  if (inherits(crw_object,"crwPredict")) {
    alpha <- data.matrix(crw_object[,c("mu.x","nu.x","mu.y","nu.y")])
    times <- crw_object[,attr(crw_object,"Time.name")]
  }
  out <- list(alpha = alpha,
              times = as.numeric(times)/ts)
  class(out) <- "crwAlpha"
  return(out)
}
```


### `get_mask_segments`

This function is used to identify sections of a path that pass through a
restricted area (e.g. for marine mammals or fish, a land mask). This function will
identify path segments from the unrestrained path that overlap the *vector_mask*.
If the path/points end within the land area, those records will be removed. The
user can then use this information to adjust the path as desired.

```{r get-mask-segments, results = 'hide'}
get_mask_segments = function(crw_sf, vector_mask, alpha) {
  
  # intersect crw_sf with vector mask
  on_mask <- sf::st_intersects(crw_sf, vector_mask) %>% 
    purrr::map_lgl(~ length(.x) > 0)
  if (any(is.na(on_mask))) {
    stop("points in crw_sf fall outside the extent of vector_mask")
  }
  # return NULL if no points within the vector mask
  if (sum(on_mask,na.rm = TRUE) == 0) {return(NULL)}
  
  head_start <- 1
  tail_end <- length(on_mask)
  
  if (min(which(on_mask == TRUE)) == 1) {
    warning(paste0("Path starts within vector mask, first ",
                   min(which(on_mask == 0)) - 1,
                   " observations removed"))
    head_start = min(which(on_mask == FALSE))
  }
  if (max(which(on_mask == 0)) < length(on_mask)) {
    warning(paste("Path ends within vector mask, last ", 
                  length(on_mask) - max(which(on_mask == 0)),
                  " observations removed"))
    tail_end <- max(which(on_mask == 0))
  }
  crw_sf <- crw_sf[head_start:tail_end,]
  on_mask <- on_mask[head_start:tail_end]
  
  in.segment <- (on_mask == TRUE)
  
  start_idx <- which(c(FALSE, in.segment) == TRUE &
                       dplyr::lag(c(FALSE, in.segment) == FALSE)) - 2
  end_idx <- which(c(in.segment, FALSE) == TRUE & 
                     dplyr::lead(c(in.segment, FALSE) == FALSE)) + 1
  on_mask_segments <- data.frame(start_idx, end_idx) %>% 
    rowwise() %>% 
    dplyr::mutate(start_alpha = list(alpha$alpha[start_idx, ]),
                  end_alpha = list(alpha$alpha[end_idx,]),
                  times = list(alpha$times[start_idx:end_idx]))
  on_mask_segments <- list(
    on_mask_segments = on_mask_segments,
    fixed_range = c(head_start,tail_end)
  )
  
  return(on_mask_segments)
}
```



```{r identify-segments, results = 'hide'}
alpha <- crw_alpha(pred1)

segments <- get_mask_segments(crw_sf = pred1_sf,
                              vector_mask = ak_sf,
                              alpha = alpha)$on_mask_segments

pred1_sf$L1 <- 0

for (i in 1:nrow(segments)) {
  start_idx <- segments$start_idx[i]
  end_idx <- segments$end_idx[i]
  pred1_sf$L1[start_idx:end_idx] <- i
}

pred1_fix <- pred1_sf %>% dplyr::group_by(L1) %>%
  dplyr::summarise(do_union=FALSE) %>%
  sf::st_cast("LINESTRING") %>% 
  dplyr::filter(L1 > 0)

ggplot() + 
  ggspatial::annotation_spatial(data = ak_sf) +
  ggspatial::layer_spatial(pred1_line, lwd = 0.75, color = '#159957') +
  ggspatial::layer_spatial(pred1_fix, lwd = 1.5, color = 'dark red') +
  ggtitle("Predicted Path Highlighting On-Land Segments", 
          subtitle = "Harbor Seal, Shelikof Strait, Alaska, USA")
```

